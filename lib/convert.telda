# Make sure that str is at least log_10(num) long (6 is max for 16-bit ints (remember the final null-byte in the string))
# [$, *str, num]
#     +2    +4  +6
IntTos:
    # use $ba for the string pointer and $ac for the calculations
    load $ba, [$sp+2]
    load $ac, [$sp+4]

num_len:
    inc $ba
    div $ac, ~10
    jnz num_len
    # put the final null byte already
    load $ab, 0
    str $ab, $ba
    dec $ba

    load $ac, [$sp+4]

loop_IntTos:
    # get the next unit by doing mod 10 and then since that'll be in 0..=9, just adding '0' will convert it to the current character
    rem $ac, ~10
    add $ab, '0'
    # then put it into the string and decrement the pointer
    str $ab, $ba
    dec $ba

    # divide by 10 to get the next number, and just return if the result is zero
    load $ac, [$sp+4]
    div $ac, ~10
    sas $ac, ~4
    jnz loop_IntTos

    ret

# Signed int to string
# Make sure that str is at least log_10(num) long (7 is max for 16-bit ints (remember the final null-byte in the string))
# [$, *str, num]
#     +2    +4  +6
SintTos:
    load $ba, [$sp+2]
    load $ac, [$sp+4]
    jns num_len

    load $ab, '-'
    str $ab, $ba
    inc $ba
    load $ac, [$sp+4]
    neg $ac
    # store it in the num arg, because it is re-loaded
    # after finding the length
    sas $ac, ~4
    # we can ignore overflow since -MIN_INT wraps to MIN_INT
    # which if interpreted unsigned is actually abs(MIN_INT)
    jump num_len

# [$, *str]
#     +2
# -> $ac
# returns number giving by the string in the $ac register
Parse:
    load $sr, [$sp+2]
    sdp
    # Check for minus
    # store multiplier in $ds
    load $ds, ~1
    sld $ab
    cmp $ab, '-'
    # If it wasn't '-', we'll assume it was a digit
    # and skip straight into the loop to the end
    jne wasnotminus_Parse
    # if it was '-', we set the multiplier
    # to be negative 1, and store the new string start
    load $ds, ~-1
    # Set string start to be after '-'
    sas $sr, ~2
loop_to_end_Parse:
    sld $ab
wasnotminus_Parse:
    cmp $ab, 0
    jne loop_to_end_Parse
    # start $ac at 0
    xor $ac, $ac
    # go through the array from the lowest digit
    sdn
    sub $sr, ~2
loop_to_start_Parse:
    cmp $sr, [$sp+2]
    jb ret_Parse
    # Make sure upper bits are zero
    load $ba, ~0
    # And read the next digit
    sld $bb
    sub $bb, '0'
    # Return zero if the digit is invalid
    cmp $bb, 9
    ja ret_zero
    # acc += $bb * $ds
    # $ds *= 10
    mul $ba, $ds
    mul $ds, ~10
    add $ac, $ba

    jmp loop_to_start_Parse

ret_zero:
    xor $ac, $ac
ret_Parse:
    sdp
    ret