# Make sure that str is at least log_10(num) long (6 is max for 16-bit ints (remember the final null-byte in the string))
# [$, *str, num]
#     +2    +4  +6
IntTos:
    # use $ds for the string pointer and $ac for the calculations
    load $ds, [$sp+2]
    load $ac, [$sp+4]
sinttos_entry_IntTos:
    load $ba, $ac
    sdn

num_len:
    inc $ds
    div $ac, ~10
    jnz num_len

    # put the final null byte already (utilise that $ac contains zero rn)
    sst 0, $ab

loop_IntTos:
    load $ac, $ba
    # get the next unit by doing mod 10 and then since that'll be in 0..=9, just adding '0' will convert it to the current character
    rem $ac, ~10
    add $ab, '0'
    # then put it into the string and decrement the pointer
    sst 0, $ab

    # divide by 10 to get the next number, and just return if the result is zero
    div $ba, ~10
    jnz loop_IntTos

    ret

# Signed int to string
# Make sure that str is at least log_10(num) long (7 is max for 16-bit ints (remember the final null-byte in the string))
# [$, *str, num]
#     +2    +4  +6
SintTos:
    load $ds, [$sp+2]
    load $ac, [$sp+4]
    jns sinttos_entry_IntTos

    load $bb, '-'
    str $bb, $ds
    inc $ds
    neg $ac
    # we can ignore overflow since -MIN_INT wraps to MIN_INT
    # which if interpreted unsigned is actually abs(MIN_INT)
    jump sinttos_entry_IntTos

# [$, *str]
#     +2
# -> $ac
# returns number giving by the string in the $ac register
Parse:
    load $sr, [$sp+2]
    sdp
    # Check for minus
    # store multiplier in $ds
    load $ds, ~1
    sld $ab
    cmp $ab, '-'
    # If it wasn't '-', we'll assume it was a digit
    # and skip straight into the loop to the end
    jne wasnotminus_Parse
    # if it was '-', we set the multiplier
    # to be negative 1, and store the new string start
    load $ds, ~-1
    # Set string start to be after '-'
    sas $sr, ~2
loop_to_end_Parse:
    sld $ab
wasnotminus_Parse:
    cmp $ab, 0
    jne loop_to_end_Parse
    # start $ac at 0
    xor $ac, $ac
    # go through the array from the lowest digit
    sdn
    sub $sr, ~2
loop_to_start_Parse:
    cmp $sr, [$sp+2]
    jb ret_Parse
    # Make sure upper bits are zero
    load $ba, ~0
    # And read the next digit
    sld $bb
    sub $bb, '0'
    # Return zero if the digit is invalid
    cmp $bb, 9
    ja ret_zero
    # acc += $bb * $ds
    # $ds *= 10
    mul $ba, $ds
    mul $ds, ~10
    add $ac, $ba

    jmp loop_to_start_Parse

ret_zero:
    xor $ac, $ac
ret_Parse:
    sdp
    ret