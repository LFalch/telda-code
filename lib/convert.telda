# Make sure that str is at least log_10(num) long (6 is max for 16-bit ints (remember the final null-byte in the string))
# [$, *str, num]
#     +2    +4  +6
IntTos:
    # use $ba for the string pointer and $ac for the calculations
    load $ba, [$sp+2]
    load $ac, [$sp+4]

num_len:
    inc $ba
    div $ac, ~10
    jnz num_len
    # put the final null byte already
    load $ab, 0
    str $ab, $ba
    dec $ba

    load $ac, [$sp+4]

loop_IntTos:
    # get the next unit by doing mod 10 and then since that'll be in 0..=9, just adding '0' will convert it to the current character
    rem $ac, ~10
    add $ab, '0'
    # then put it into the string and decrement the pointer
    str $ab, $ba
    dec $ba

    # divide by 10 to get the next number, and just return if the result is zero
    load $ac, [$sp+4]
    div $ac, ~10
    sas $ac, ~4
    jnz loop_IntTos

    ret

# [$, *str]
#     +2
# -> $ac
# returns number giving by the string in the $ac register
Parse:
    load $sr, [$sp+2]
    sdp
loop_to_end_Parse:
    sld $ab
    cmp $ab, 0
    jne loop_to_end_Parse
    # start $ac at 0
    xor $ac, $ac
    # go through the array from the lowest digit
    sdn
    sub $sr, ~2
    # multiplier
    load $ds, ~1
loop_to_start_Parse:
    cmp $sr, [$sp+2]
    jlt ret_Parse
    # Make sure upper bits are zero
    load $ba, ~0
    # And read the next digit
    sld $bb
    sub $bb, '0'
    # Return zero if the digit is invalid
    cmp $bb, 9
    jgt ret_zero
    # acc += $bb * $ds
    # $ds *= 10
    mul $ba, $ds
    mul $ds, ~10
    add $ac, $ba

    jmp loop_to_start_Parse

ret_zero:
    xor $ac, $ac
ret_Parse:
    sdp
    ret